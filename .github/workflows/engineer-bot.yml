name: Engineer Bot - Implementation
on:
  repository_dispatch:
    types: ["🛠️ Lets Build This"]

jobs:
  engineer:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      attestations: none
      checks: write
      contents: write
      deployments: read
      discussions: write
      id-token: none
      issues: write
      models: read
      packages: read
      pages: read
      pull-requests: write
      security-events: read
      statuses: write
    if: github.event_name == 'repository_dispatch'
    env:
      ISSUE_NUMBER: ${{ github.event.client_payload.issue_number || github.event.issue.number }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v3
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Build project
        run: cargo build --verbose

      - name: Run tests
        run: cargo test --verbose

      - uses: convcha/claude-code-action@main
        env:
          RUST_VERSION: "stable"
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          timeout_minutes: "30"
          allowed_tools: |
            [
              "Bash",
              "Glob",
              "Grep", 
              "LS",
              "Read",
              "Edit",
              "MultiEdit",
              "Write",
              "Task",
              "GitHubCreateIssue",
              "GitHubEditIssue",
              "GitHubCloseIssue",
              "GitHubCreatePullRequest",
              "GitHubEditPullRequest",
              "GitHubGetIssue",
              "GitHubGetPullRequest",
              "GitHubListIssues",
              "GitHubListPullRequests",
              "GitHubSearchIssues",
              "GitHubAddLabelsToIssue",
              "GitHubRemoveLabelsFromIssue",
              "GitHubAddAssigneesToIssue", 
              "GitHubRemoveAssigneesFromIssue",
              "GitHubCreateIssueComment",
              "GitHubUpdateIssueComment",
              "GitHubDeleteIssueComment",
              "GitHubListIssueComments",
              "GitHubCreatePullRequestReview",
              "GitHubCreatePullRequestReviewComment",
              "GitHubUpdatePullRequestReviewComment",
              "GitHubDeletePullRequestReviewComment",
              "GitHubListPullRequestReviewComments",
              "GitHubRequestPullRequestReviewers",
              "GitHubRemovePullRequestReviewRequest",
              "GitHubMergePullRequest",
              "GitHubAddLabelsToLabelable",
              "GitHubRemoveLabelsFromLabelable"
            ]
          disallowed_tools: |
            [
              "GitHubDeleteRepository",
              "GitHubCreateRepository",
              "GitHubUpdateRepository"
            ]
          custom_instructions: |
            You are an Engineer AI bot working as part of the Machiners Platoon AI development team.
            
            Your role is to implement features and fixes for the rust-wc project (a Rust word count utility).
            
            Key responsibilities:
            1. **Code Implementation**: Write clean, efficient Rust code following best practices
            2. **Testing**: Create comprehensive tests for new functionality
            3. **Documentation**: Add appropriate comments and documentation
            4. **Quality Assurance**: Ensure code passes formatting, linting, and testing
            5. **Pull Request Creation**: Create well-documented PRs with clear descriptions
            
            Project Context:
            - Rust CLI application for word counting
            - Uses getopts for command-line parsing
            - Modular structure with counter/ and main modules
            - Focus on performance and memory safety
            
            Development Standards:
            - Follow Rust idioms and conventions
            - Use proper error handling with Result types
            - Write unit tests for new functionality
            - Run cargo fmt and cargo clippy
            - Maintain backward compatibility
            
            Always create a feature branch and submit a PR for review.
          direct_prompt: |
            Please implement the feature or fix described in the issue.
            
            Steps to follow:
            1. Read and understand the issue requirements
            2. Analyze the current codebase structure
            3. Create a feature branch for the implementation
            4. Implement the required changes:
               - Write clean, idiomatic Rust code
               - Add appropriate error handling
               - Create comprehensive tests
               - Update documentation if needed
            5. Ensure code quality:
               - Run cargo fmt
               - Run cargo clippy
               - Run cargo test
               - Verify all checks pass
            6. Create a pull request with:
               - Clear title and description
               - Link to the original issue
               - Testing instructions
               - Any breaking changes noted
            7. Request review from System Architect Bot

      - name: Track Claude execution cost
        uses: ./.github/actions/claude-result-tracker
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ env.ISSUE_NUMBER }}
          cost-name: "Engineer Bot"

      - name: Trigger Architect Review Bot
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PERSONAL_ACCESS_TOKEN }}
          script: |
            // Get the PR number from the latest PR created by this workflow
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'desc',
              per_page: 1
            });
            
            if (prs.data.length > 0) {
              const prNumber = prs.data[0].number;
              
              await github.rest.repos.createDispatchEvent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event_type: "🏗️ Architect PR Review",
                client_payload: {
                  pr_number: prNumber,
                  issue_number: ${{ env.ISSUE_NUMBER }}
                }
              });
            }